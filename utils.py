from dotenv import load_dotenv
from datetime import timezone, datetime
from zoneinfo import ZoneInfo
from settings import load_settings
from pathlib import Path
from openai import OpenAI
import logging
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import os
import re
import json
from typing import Iterable
settings = load_settings(Path("pyproject.toml"))[1]
load_dotenv()
llm_api_key = os.getenv("LLM_API_KEY", None)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

PROCESSED_IDS_FILE = Path("cache/processed_ids.json")


def _today_str() -> str:
    return to_timezone_time(datetime.now(), settings.timezone).strftime("%Y-%m-%d")


def load_processed_ids() -> set[str]:
    today = _today_str()
    try:
        if PROCESSED_IDS_FILE.exists():
            with open(PROCESSED_IDS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                if isinstance(data, dict) and data.get("date") == today and isinstance(data.get("ids"), list):
                    return set(str(x) for x in data["ids"])
    except Exception as e:
        logger.warning(f"Failed to load processed ids cache: {e}")
    return set()


def append_processed_ids(new_ids: Iterable[str]) -> None:
    today = _today_str()
    existing: set[str] = load_processed_ids()
    before = len(existing)
    existing.update(str(x) for x in new_ids)
    if len(existing) == before:
        logger.info("No new paper IDs to append to today's cache.")
        return
    payload = {"date": today, "ids": sorted(existing)}
    PROCESSED_IDS_FILE.parent.mkdir(parents=True, exist_ok=True)
    try:
        with open(PROCESSED_IDS_FILE, 'w', encoding='utf-8') as f:
            json.dump(payload, f, ensure_ascii=False, indent=2)
        logger.info(
            f"Updated today's processed ids cache: +{len(existing)-before} (total {len(existing)})")
    except Exception as e:
        logger.error(f"Failed to write processed ids cache: {e}")


def to_timezone_time(date: datetime, timezone_str=settings.timezone) -> datetime:
    TIMEZONE = ZoneInfo(timezone_str)
    if date.tzinfo is None:
        date = date.replace(tzinfo=timezone.utc)
    return date.astimezone(TIMEZONE)


def get_llm_json_response(system_prompt: str, user_prompt: str) -> str | None:
    client = OpenAI(
        api_key=llm_api_key,
        base_url=settings.llm_base_url,
    )
    response = client.chat.completions.create(
        model=settings.llm_model_name,
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ],
        response_format={
            'type': 'json_object'
        }
    )
    return response.choices[0].message.content


def send_email(attachment_paths: list[Path]) -> None:
    msg = MIMEMultipart()
    msg['From'] = settings.email_sender
    msg['To'] = settings.email_receivers
    current_date = datetime.now()
    current_date = to_timezone_time(
        current_date, settings.timezone).strftime("%Y-%m-%d")
    msg['Subject'] = f"{current_date} - Recommended Papers"
    body = f"""
    <html>
      <body>
        <h2>{current_date} - Arxiv Daily</h2>
        <p>Hello,</p>
        <p>Here are today's recommended papers:</p>
        <p>For more details, please see the attachments.</p>
        <hr>
        <p style="color: gray; font-size: 12px;">This email is automatically generated by the system, please do not reply.</p>
      </body>
    </html>
    """
    msg.attach(MIMEText(body, 'html'))

    for file_path in attachment_paths:
        if not file_path.exists() or not file_path.is_file():
            continue
        with open(file_path, "rb") as attachment:
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(attachment.read())
            encoders.encode_base64(part)
            part.add_header(
                'Content-Disposition',
                f'attachment; filename= {file_path.name}',
            )
            msg.attach(part)

    try:
        with smtplib.SMTP(settings.smtp_server, settings.smtp_port) as server:
            server.starttls()
            server.login(settings.smtp_username,
                         os.getenv("SMTP_PASSWORD", ""))
            server.send_message(msg)
        logging.info("Email sent successfully.")
    except Exception as e:
        logging.error(f"Failed to send email: {e}")
